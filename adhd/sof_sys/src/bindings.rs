// Copyright 2020 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
/*
 * generated from files in sound-open-firmware-private/src/include:
 * kernel/header.h
 * ipc/control.h
 */

/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type __uint32_t = ::std::os::raw::c_uint;
#[doc = " \\brief Header for all non IPC ABI data."]
#[doc = ""]
#[doc = " Identifies data type, size and ABI."]
#[doc = " Data header used for all component data structures and binary blobs sent to"]
#[doc = " firmware as runtime data. This data is typically sent by userspace"]
#[doc = " applications and tunnelled through any OS kernel (via binary kcontrol on"]
#[doc = " Linux) to the firmware."]
#[repr(C, packed)]
pub struct sof_abi_hdr {
    #[doc = "< 'S', 'O', 'F', '\\0'"]
    pub magic: u32,
    #[doc = "< component specific type"]
    pub type_: u32,
    #[doc = "< size in bytes of data excl. this struct"]
    pub size: u32,
    #[doc = "< SOF ABI version"]
    pub abi: u32,
    #[doc = "< reserved for future use"]
    pub reserved: [u32; 4usize],
    #[doc = "< Component data - opaque to core"]
    pub data: __IncompleteArrayField<u32>,
}
#[test]
fn bindgen_test_layout_sof_abi_hdr() {
    assert_eq!(
        ::std::mem::size_of::<sof_abi_hdr>(),
        32usize,
        concat!("Size of: ", stringify!(sof_abi_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<sof_abi_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(sof_abi_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sof_abi_hdr>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sof_abi_hdr>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sof_abi_hdr>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sof_abi_hdr>())).abi as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(abi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sof_abi_hdr>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sof_abi_hdr>())).data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "< maps to ALSA volume style controls"]
pub const sof_ipc_ctrl_cmd_SOF_CTRL_CMD_VOLUME: sof_ipc_ctrl_cmd = 0;
#[doc = "< maps to ALSA enum style controls"]
pub const sof_ipc_ctrl_cmd_SOF_CTRL_CMD_ENUM: sof_ipc_ctrl_cmd = 1;
#[doc = "< maps to ALSA switch style controls"]
pub const sof_ipc_ctrl_cmd_SOF_CTRL_CMD_SWITCH: sof_ipc_ctrl_cmd = 2;
#[doc = "< maps to ALSA binary style controls"]
pub const sof_ipc_ctrl_cmd_SOF_CTRL_CMD_BINARY: sof_ipc_ctrl_cmd = 3;
#[doc = " Control command type."]
pub type sof_ipc_ctrl_cmd = ::std::os::raw::c_uint;
