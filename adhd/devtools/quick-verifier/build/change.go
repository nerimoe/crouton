// Copyright 2023 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package main

import (
	"fmt"
	"log"
	"strings"

	"github.com/andygrunwald/go-gerrit"
	"golang.org/x/exp/slices"
)

func processChange(gerritClient *gerrit.Client, change gerrit.ChangeInfo) {
	cl := gerritCL{changeID: change.Number, revisionID: change.Revisions[change.CurrentRevision].Number}

	log.Println("processing", cl.url())

	var state state
	var triggerID string
	for _, message := range change.Messages {
		if message.Author.AccountID != botID || cl.revisionID != message.RevisionNumber {
			// Ignore non-self activity.
			continue
		}
		if id, ok := getTriggerIDFromMessage(message.Message); ok {
			triggerID = id
			state = triggeredState
			continue
		}
		if strings.Contains(message.Message, "complete:") {
			state = completedState
		}
	}

	if state == completedState {
		if slices.Contains(change.Hashtags, audioQVTrigger) {
			state = newState
		} else {
			log.Println("already voted")
			return
		}
	}

	if state == newState {
		triggerID = randomTriggerID()
		log.Println("Triggering", triggerID)

		if err := submit(cl, triggerID); err != nil {
			log.Fatalf("Cannot submit %v", err)
		}

		review := &gerrit.ReviewInput{
			Message: fmt.Sprintf(
				"[audio-qv](https://goto.google.com/chromeos-audio-qv) is testing this patchset.\nTrigger ID: %s\nLogs: %s",
				triggerID,
				buildURL(triggerID),
			),
			Notify:                           "NONE",
			IgnoreAutomaticAttentionSetRules: true,
			Tag:                              "autogenerated:audio-qv~trigger",
		}
		if _, _, err := gerritClient.Changes.SetReview(change.ChangeID, change.CurrentRevision, review); err != nil {
			log.Fatal("Cannot post starting comment: ", err)
		}

		log.Println("Logs:", buildURL(triggerID))
	} else if state == triggeredState {
		log.Println("Detecting job status from GCB")

		br, err := queryBuilds(triggerID)
		if err == running {
			log.Println("Build still running")
			return
		}
		if err != nil {
			log.Fatalln("Unhandled error queryBuilds(): ", err)
		}

		var verified string
		if br.ok() {
			verified = "+1"
		} else {
			verified = "-1"
		}
		message := fmt.Sprintf("[audio-qv](https://goto.google.com/chromeos-audio-qv) complete:\n%s", br.String())

		log.Println("Build completed")

		if slices.Contains(change.Hashtags, audioQVTrigger) {
			if _, _, err := gerritClient.Changes.SetHashtags(change.ChangeID, &gerrit.HashtagsInput{
				Remove: []string{audioQVTrigger},
			}); err != nil {
				log.Fatalf("Cannot remove hashtag %q: %v", change.Hashtags, err)
			}
		}

		review := &gerrit.ReviewInput{
			Labels: map[string]string{
				"Verified": verified,
			},
			Message: message,
			Tag:     "autogenerated:audio-qv~result",
		}
		if verified == "+1" {
			// Make a silent vote which does not generate emails.
			review.Notify = "NONE"
			review.IgnoreAutomaticAttentionSetRules = true
		}
		log.Println("Setting Verified", verified)

		_, _, err = gerritClient.Changes.SetReview(change.ChangeID, change.CurrentRevision, review)
		if err != nil {
			log.Fatalf("Cannot set review %v", err)
		}
	}
}
